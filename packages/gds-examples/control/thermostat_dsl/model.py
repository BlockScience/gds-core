"""Thermostat PID Control -- gds-control DSL version.

Reimplements the manual thermostat PID model (thermostat/) using the
gds-control declarative DSL. Instead of manually constructing TypeDefs,
Entities, Spaces, Blocks, and wiring them together, we declare States,
Inputs, Sensors, and Controllers -- the compiler handles all GDS mapping.

Key Difference from Raw GDS Version:
    The raw thermostat uses .feedback() with CONTRAVARIANT wiring to model
    within-timestep energy cost feedback (Room Plant -> PID Controller).
    The control DSL generates .loop() with COVARIANT temporal wiring only.
    The energy cost feedback path is NOT captured in this DSL version --
    the DSL provides a higher-level structural view focused on the
    state-space control loop (sensors -> controller -> dynamics).

    If within-timestep backward information flow is essential, use the
    raw GDS API (see thermostat/model.py).

Concepts Covered:
    - gds-control DSL: State, Input, Sensor, Controller declarations
    - compile_model() -> GDSSpec (automatic type/space/entity/block generation)
    - compile_to_system() -> SystemIR (automatic composition with .loop())
    - Multi-state entity: temperature + energy_consumed
    - Single controller driving multiple states
    - Temporal loop (.loop()) -- state feeds back to sensor across timesteps
    - Comparison with raw GDS .feedback() version (thermostat/)

Prerequisites: thermostat (for raw GDS with .feedback()), double_integrator
               (for control DSL basics)

GDS Decomposition (auto-generated by compiler):
    X  = (temperature, energy_consumed) -- 2D state: room conditions
    U  = setpoint                       -- exogenous reference temperature
    g  = (temp_sensor, PID)             -- observation + control law
    f  = (temperature Dynamics, energy_consumed Dynamics)  -- state transition
    Theta = {}                          -- no explicit parameters in DSL

Composition (auto-generated):
    (setpoint | temp_sensor) >> PID
        >> (temperature Dynamics | energy_consumed Dynamics)
    .loop([
        temperature Dynamics -> temp_sensor (COVARIANT),
    ])
"""

from gds.canonical import CanonicalGDS, project_canonical
from gds.ir.models import SystemIR
from gds.spec import GDSSpec
from gds_control.dsl.compile import compile_model, compile_to_system
from gds_control.dsl.elements import Controller, Input, Sensor, State
from gds_control.dsl.model import ControlModel


def build_model() -> ControlModel:
    """Declare the thermostat PID system as a ControlModel.

    The model captures the *structure* of a PID-controlled thermostat:
    two coupled states (temperature driven by PID output, energy_consumed
    tracking cumulative energy use), one temperature sensor, and a single
    PID controller that reads the sensor and the reference setpoint.

    No numerical values (PID gains Kp, Ki, Kd) are specified -- GDS is
    structural, not numerical. The compiler infers all types, spaces,
    entities, blocks, and wirings from these declarations.

    Note: The raw thermostat model includes a ControlAction (Room Plant)
    with backward_out for within-timestep energy cost feedback. The
    control DSL abstracts this away -- it focuses on the forward
    control loop topology.
    """
    return ControlModel(
        name="Thermostat PID",
        states=[
            State(name="temperature", initial=20.0),
            State(name="energy_consumed", initial=0.0),
        ],
        inputs=[Input(name="setpoint")],
        sensors=[
            Sensor(name="temp_sensor", observes=["temperature"]),
        ],
        controllers=[
            Controller(
                name="PID",
                reads=["temp_sensor", "setpoint"],
                drives=["temperature", "energy_consumed"],
            ),
        ],
        description="PID-controlled thermostat with temperature and energy tracking",
    )


def build_spec() -> GDSSpec:
    """Compile the ControlModel to a full GDSSpec.

    The compiler automatically generates:
    - 4 semantic types: StateType, ReferenceType, MeasurementType, ControlType
    - 4 semantic spaces: StateSpace, ReferenceSpace, MeasurementSpace,
      ControlSpace
    - 2 entities: temperature (value), energy_consumed (value)
    - 5 blocks: 1 BoundaryAction (setpoint), 1 Policy-sensor (temp_sensor),
                1 Policy-controller (PID),
                2 Mechanisms (temperature/energy_consumed Dynamics)
    - 1 SpecWiring with all inter-block connections
    """
    return compile_model(build_model())


def build_system() -> SystemIR:
    """Compile the ControlModel to SystemIR via the composition tree.

    The compiler builds:
        (setpoint | temp_sensor) >> PID
            >> (temperature Dynamics | energy_consumed Dynamics)
        .loop([
            temperature Dynamics -> temp_sensor (COVARIANT),
        ])

    The .loop() creates temporal recurrence -- the temperature state output
    at timestep t feeds the temp_sensor input at timestep t+1.

    Note: Unlike the raw thermostat, there is no .feedback() (CONTRAVARIANT)
    for energy cost. The control DSL models the forward control loop only.
    """
    return compile_to_system(build_model())


def build_canonical() -> CanonicalGDS:
    """Project the canonical h = f . g decomposition.

    For the thermostat PID:
        |X| = 2  (temperature, energy_consumed) -- dim(x) = 2
        |U| = 1  (setpoint)                     -- dim(u) = 1
        |g| = 2  (temp_sensor + PID)            -- observation + control law
        |f| = 2  (2 dynamics mechanisms)         -- state transition
    """
    return project_canonical(build_spec())
