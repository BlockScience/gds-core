"""Double Integrator — classical state-space control via the gds-control DSL.

Demonstrates the gds-control declarative DSL that compiles to GDS primitives.
A point mass with position and velocity states is driven by a single force
input through a PD controller. Two sensors independently observe position
and velocity, and a single controller fuses both measurements with the
reference input to produce a control command.

This is the classical state-space form:
    ẋ = Ax + Bu    →    x_{t+1} = f(x_t, u_t)    (GDS mechanisms)
    y = Cx         →    y_t = g(x_t)               (GDS policies — sensors)
    u = Ky + r     →    u_t = g(y_t, r_t)          (GDS policy — controller)

Concepts Covered:
    - gds-control DSL: State, Input, Sensor, Controller declarations
    - compile_model() → GDSSpec (automatic type/space/entity/block generation)
    - compile_to_system() → SystemIR (automatic composition with .loop())
    - State-space correspondence: (A,B,C,D) ↔ (X,U,g,f)
    - Multi-state entity with coupled dynamics
    - Single controller reading multiple sensors
    - Temporal loop (.loop()) — state feeds back to sensors across timesteps

Prerequisites: thermostat (for raw GDS control), sir_epidemic (for basic GDS)

GDS Decomposition (auto-generated by compiler):
    X  = (position, velocity)    — 2D state: rows of A
    U  = force                   — exogenous reference: cols of B
    g  = (pos_sensor, vel_sensor, PD)  — observation + control law: C and K
    f  = (position Dynamics, velocity Dynamics)  — state transition: A
    Θ  = {}                      — no explicit parameters in this model

Composition (auto-generated):
    (force | pos_sensor | vel_sensor) >> PD >> (position Dynamics | velocity Dynamics)
        .loop([position Dynamics → pos_sensor, velocity Dynamics → vel_sensor])
"""

from gds.canonical import CanonicalGDS, project_canonical
from gds.ir.models import SystemIR
from gds.spec import GDSSpec

from gds_control.dsl.compile import compile_model, compile_to_system
from gds_control.dsl.elements import Controller, Input, Sensor, State
from gds_control.dsl.model import ControlModel


def build_model() -> ControlModel:
    """Declare the double integrator as a ControlModel.

    The model captures the *structure* of a classical double integrator:
    two coupled states (position driven by velocity, velocity driven by force),
    two independent sensors, and a single PD controller that fuses both
    measurements with the reference input.

    No numerical values (A, B, C, D matrices) are specified — GDS is
    structural, not numerical. The compiler infers all types, spaces,
    entities, blocks, and wirings from these declarations.
    """
    return ControlModel(
        name="Double Integrator",
        states=[
            State(name="position", initial=0.0),
            State(name="velocity", initial=0.0),
        ],
        inputs=[Input(name="force")],
        sensors=[
            Sensor(name="pos_sensor", observes=["position"]),
            Sensor(name="vel_sensor", observes=["velocity"]),
        ],
        controllers=[
            Controller(
                name="PD",
                reads=["pos_sensor", "vel_sensor", "force"],
                drives=["position", "velocity"],
            ),
        ],
    )


def build_spec() -> GDSSpec:
    """Compile the ControlModel to a full GDSSpec.

    The compiler automatically generates:
    - 4 semantic types: StateType, ReferenceType, MeasurementType, ControlType
    - 4 semantic spaces: StateSpace, ReferenceSpace, MeasurementSpace, ControlSpace
    - 2 entities: position (value), velocity (value)
    - 6 blocks: 1 BoundaryAction (force), 2 Policy-sensors, 1 Policy-controller,
                2 Mechanisms (position/velocity Dynamics)
    - 1 SpecWiring with all inter-block connections
    """
    return compile_model(build_model())


def build_system() -> SystemIR:
    """Compile the ControlModel to SystemIR via the composition tree.

    The compiler builds:
        (force | pos_sensor | vel_sensor) >> PD >> (position Dynamics | velocity Dynamics)
            .loop([
                position Dynamics → pos_sensor (COVARIANT),
                velocity Dynamics → vel_sensor (COVARIANT),
            ])

    The .loop() creates temporal recurrence — state outputs at timestep t
    feed sensor inputs at timestep t+1.
    """
    return compile_to_system(build_model())


def build_canonical() -> CanonicalGDS:
    """Project the canonical h = f ∘ g decomposition.

    For the double integrator:
        |X| = 2  (position, velocity)     — dim(x) = rows(A)
        |U| = 1  (force)                  — dim(u) = cols(B)
        |g| = 3  (2 sensors + PD)         — observation C + control law K
        |f| = 2  (2 dynamics mechanisms)  — state transition A
    """
    return project_canonical(build_spec())
