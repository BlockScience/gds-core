"""Lotka-Volterra Predator-Prey â€” StockFlow DSL version.

Reimplements the manual Lotka-Volterra model (lotka_volterra/) using the
gds-stockflow declarative DSL. Instead of manually constructing TypeDefs,
Entities, Spaces, Blocks, and wiring them together, we declare Stocks,
Flows, Auxiliaries, and Converters -- the compiler handles all GDS mapping.

Concepts Covered:
    - StockFlowModel declarative API for predator-prey dynamics
    - compile_model() -> GDSSpec (automatic type/space/entity/block generation)
    - compile_to_system() -> SystemIR (automatic composition with .loop())
    - verify() -- SF-001..SF-005 + GDS G-001..G-006
    - Temporal loops (cross-timestep population feedback)
    - Comparison with manual GDS construction (lotka_volterra/)

Prerequisites: sir_epidemic_dsl (basic stockflow DSL), lotka_volterra (manual GDS)

GDS Decomposition (auto-generated by compiler):
    X  = (Prey.level, Predator.level)
    U  = (Prey Birth Rate, Predation Rate, Predator Death Rate,
           Predator Efficiency) -- exogenous converters
    g  = (Prey Growth, Predation Loss, Predator Growth,
           Predator Death, Prey Net Change, Predator Net Change)
    f  = (Prey Accumulation, Predator Accumulation)
    Theta = {Prey Birth Rate, Predation Rate, Predator Death Rate,
             Predator Efficiency}

Composition (auto-generated):
    (Prey Birth Rate | Predation Rate | Predator Death Rate
        | Predator Efficiency)
    >> (Prey Growth | Predation Loss | Predator Growth | Predator Death)
    >> (Prey Net Change | Predator Net Change)
    >> (Prey Accumulation | Predator Accumulation)
    .loop([Prey Accumulation -> Prey Growth,
           Prey Accumulation -> Predation Loss,
           Predator Accumulation -> Predation Loss,
           Predator Accumulation -> Predator Growth,
           Predator Accumulation -> Predator Death])
"""

from gds.canonical import CanonicalGDS, project_canonical
from gds.ir.models import SystemIR
from gds.spec import GDSSpec
from stockflow.dsl.compile import compile_model, compile_to_system
from stockflow.dsl.elements import Auxiliary, Converter, Flow, Stock
from stockflow.dsl.model import StockFlowModel


def build_model() -> StockFlowModel:
    """Declare the Lotka-Volterra system as a StockFlowModel.

    The model captures the *structure* of a predator-prey system:
    two population stocks (Prey, Predator) connected by flows that
    represent growth, predation, and death processes.

    The Lotka-Volterra equations are:
        dx/dt = alpha*x - beta*x*y    (prey growth minus predation)
        dy/dt = delta*x*y - gamma*y   (predator growth minus death)

    We decompose these into four rate auxiliaries:
        - Prey Growth:      alpha * x
        - Predation Loss:   beta * x * y  (drains Prey, feeds Predator Growth)
        - Predator Growth:  delta * x * y
        - Predator Death:   gamma * y

    Two net-change flows aggregate these into stock-level changes:
        - Prey Net Change:      Prey Growth - Predation Loss
        - Predator Net Change:  Predator Growth - Predator Death

    Four converters provide the exogenous rate parameters (alpha, beta,
    gamma, delta). The compiler infers all types, spaces, entities,
    blocks, and wirings from these declarations.
    """
    return StockFlowModel(
        name="Lotka-Volterra",
        stocks=[
            Stock(name="Prey", initial=100.0),
            Stock(name="Predator", initial=20.0),
        ],
        flows=[
            # Prey Net Change: aggregated rate for prey population
            Flow(name="Prey Net Change", target="Prey"),
            # Predator Net Change: aggregated rate for predator population
            Flow(name="Predator Net Change", target="Predator"),
        ],
        auxiliaries=[
            # Prey growth: alpha * x (depends on Prey and Prey Birth Rate)
            Auxiliary(
                name="Prey Growth",
                inputs=["Prey", "Prey Birth Rate"],
            ),
            # Predation loss: beta * x * y (depends on both populations + rate)
            Auxiliary(
                name="Predation Loss",
                inputs=["Prey", "Predator", "Predation Rate"],
            ),
            # Predator growth: delta * x * y (depends on both populations + efficiency)
            Auxiliary(
                name="Predator Growth",
                inputs=["Prey", "Predator", "Predator Efficiency"],
            ),
            # Predator death: gamma * y (depends on Predator and death rate)
            Auxiliary(
                name="Predator Death",
                inputs=["Predator", "Predator Death Rate"],
            ),
        ],
        converters=[
            Converter(name="Prey Birth Rate"),
            Converter(name="Predation Rate"),
            Converter(name="Predator Death Rate"),
            Converter(name="Predator Efficiency"),
        ],
        description="Lotka-Volterra predator-prey dynamics",
    )


def build_spec() -> GDSSpec:
    """Compile the StockFlowModel to a full GDSSpec.

    The compiler automatically generates:
    - 4 semantic types: Level, UnconstrainedLevel, Rate, Signal
    - 4 semantic spaces: LevelSpace, UnconstrainedLevelSpace, RateSpace,
      SignalSpace
    - 2 entities: Prey (level), Predator (level)
    - 12 blocks: 4 BoundaryAction (converters), 4 Policy-auxiliaries,
                 2 Policy-flows, 2 Mechanisms (stock accumulations)
    - 1 SpecWiring with all inter-block connections
    - 4 parameters: Prey Birth Rate, Predation Rate, Predator Death Rate,
                    Predator Efficiency
    """
    return compile_model(build_model())


def build_system() -> SystemIR:
    """Compile the StockFlowModel to SystemIR via the composition tree.

    The compiler builds:
        (Prey Birth Rate | Predation Rate | Predator Death Rate
            | Predator Efficiency)
        >> (Prey Growth | Predation Loss | Predator Growth | Predator Death)
        >> (Prey Net Change | Predator Net Change)
        >> (Prey Accumulation | Predator Accumulation)
        .loop([
            Prey Accumulation -> Prey Growth (COVARIANT),
            Prey Accumulation -> Predation Loss (COVARIANT),
            Predator Accumulation -> Predation Loss (COVARIANT),
            Predator Accumulation -> Predator Growth (COVARIANT),
            Predator Accumulation -> Predator Death (COVARIANT),
        ])

    The .loop() creates temporal recurrence -- stock levels at timestep t
    feed auxiliary computations at timestep t+1.
    """
    return compile_to_system(build_model())


def build_canonical() -> CanonicalGDS:
    """Project the canonical h = f . g decomposition.

    For the Lotka-Volterra system:
        |X| = 2  (Prey, Predator levels)
        |U| = 4  (Prey Birth Rate, Predation Rate, Predator Death Rate,
                   Predator Efficiency)
        |g| = 6  (4 auxiliaries + 2 flows)
        |f| = 2  (2 stock accumulation mechanisms)
    """
    return project_canonical(build_spec())
